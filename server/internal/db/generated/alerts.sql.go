// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: alerts.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUserAlert = `-- name: CreateUserAlert :one
INSERT INTO user_alerts (user_uuid, resort_uuid, min_snow_amount, notification_days)
VALUES ($1, $2, $3, $4) RETURNING id, user_uuid, resort_uuid, min_snow_amount, notification_days, active, created_at
`

type CreateUserAlertParams struct {
	UserUuid         uuid.NullUUID `json:"user_uuid"`
	ResortUuid       uuid.NullUUID `json:"resort_uuid"`
	MinSnowAmount    float64       `json:"min_snow_amount"`
	NotificationDays int32         `json:"notification_days"`
}

func (q *Queries) CreateUserAlert(ctx context.Context, arg CreateUserAlertParams) (UserAlert, error) {
	row := q.queryRow(ctx, q.createUserAlertStmt, createUserAlert,
		arg.UserUuid,
		arg.ResortUuid,
		arg.MinSnowAmount,
		arg.NotificationDays,
	)
	var i UserAlert
	err := row.Scan(
		&i.ID,
		&i.UserUuid,
		&i.ResortUuid,
		&i.MinSnowAmount,
		&i.NotificationDays,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAllUserAlerts = `-- name: DeleteAllUserAlerts :exec
DELETE FROM user_alerts
WHERE user_uuid = (SELECT uuid FROM users WHERE email = $1)
`

func (q *Queries) DeleteAllUserAlerts(ctx context.Context, email string) error {
	_, err := q.exec(ctx, q.deleteAllUserAlertsStmt, deleteAllUserAlerts, email)
	return err
}

const deleteUserAlert = `-- name: DeleteUserAlert :exec
DELETE FROM user_alerts
WHERE user_uuid = (SELECT uuid FROM users WHERE email = $1)
  AND resort_uuid = $2
`

type DeleteUserAlertParams struct {
	Email      string        `json:"email"`
	ResortUuid uuid.NullUUID `json:"resort_uuid"`
}

func (q *Queries) DeleteUserAlert(ctx context.Context, arg DeleteUserAlertParams) error {
	_, err := q.exec(ctx, q.deleteUserAlertStmt, deleteUserAlert, arg.Email, arg.ResortUuid)
	return err
}

const getResortAlerts = `-- name: GetResortAlerts :many
SELECT id, user_uuid, resort_uuid, min_snow_amount, notification_days, active, created_at
FROM user_alerts
WHERE resort_uuid = $1
  and active = true
`

func (q *Queries) GetResortAlerts(ctx context.Context, resortUuid uuid.NullUUID) ([]UserAlert, error) {
	rows, err := q.query(ctx, q.getResortAlertsStmt, getResortAlerts, resortUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserAlert{}
	for rows.Next() {
		var i UserAlert
		if err := rows.Scan(
			&i.ID,
			&i.UserUuid,
			&i.ResortUuid,
			&i.MinSnowAmount,
			&i.NotificationDays,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAlert = `-- name: GetUserAlert :one
SELECT id, user_uuid, resort_uuid, min_snow_amount, notification_days, active, created_at
FROM user_alerts
WHERE user_uuid = $1
  AND resort_uuid = $2 LIMIT 1
`

type GetUserAlertParams struct {
	UserUuid   uuid.NullUUID `json:"user_uuid"`
	ResortUuid uuid.NullUUID `json:"resort_uuid"`
}

func (q *Queries) GetUserAlert(ctx context.Context, arg GetUserAlertParams) (UserAlert, error) {
	row := q.queryRow(ctx, q.getUserAlertStmt, getUserAlert, arg.UserUuid, arg.ResortUuid)
	var i UserAlert
	err := row.Scan(
		&i.ID,
		&i.UserUuid,
		&i.ResortUuid,
		&i.MinSnowAmount,
		&i.NotificationDays,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const getUserAlertsByEmail = `-- name: GetUserAlertsByEmail :many
SELECT ua.id,
       ua.user_uuid,
       ua.resort_uuid,
       r.name as resort_name,
       ua.min_snow_amount,
       ua.notification_days,
       ua.active,
       ua.created_at
FROM user_alerts ua
         JOIN users u ON ua.user_uuid = u.uuid
         JOIN resorts r ON ua.resort_uuid = r.uuid
WHERE u.email = $1 AND ua.active = true
`

type GetUserAlertsByEmailRow struct {
	ID               int32         `json:"id"`
	UserUuid         uuid.NullUUID `json:"user_uuid"`
	ResortUuid       uuid.NullUUID `json:"resort_uuid"`
	ResortName       string        `json:"resort_name"`
	MinSnowAmount    float64       `json:"min_snow_amount"`
	NotificationDays int32         `json:"notification_days"`
	Active           sql.NullBool  `json:"active"`
	CreatedAt        sql.NullTime  `json:"created_at"`
}

func (q *Queries) GetUserAlertsByEmail(ctx context.Context, email string) ([]GetUserAlertsByEmailRow, error) {
	rows, err := q.query(ctx, q.getUserAlertsByEmailStmt, getUserAlertsByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserAlertsByEmailRow{}
	for rows.Next() {
		var i GetUserAlertsByEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.UserUuid,
			&i.ResortUuid,
			&i.ResortName,
			&i.MinSnowAmount,
			&i.NotificationDays,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveAlerts = `-- name: ListActiveAlerts :many
SELECT ua.id,
       ua.user_uuid,
       u.email,
       u.phone,
       ua.resort_uuid,
       r.name as resort_name,
       ua.min_snow_amount,
       ua.notification_days
FROM user_alerts ua
         JOIN users u ON ua.user_uuid = u.id
         JOIN resorts r ON ua.resort_uuid = r.uuid
WHERE ua.active = true
`

type ListActiveAlertsRow struct {
	ID               int32          `json:"id"`
	UserUuid         uuid.NullUUID  `json:"user_uuid"`
	Email            string         `json:"email"`
	Phone            sql.NullString `json:"phone"`
	ResortUuid       uuid.NullUUID  `json:"resort_uuid"`
	ResortName       string         `json:"resort_name"`
	MinSnowAmount    float64        `json:"min_snow_amount"`
	NotificationDays int32          `json:"notification_days"`
}

func (q *Queries) ListActiveAlerts(ctx context.Context) ([]ListActiveAlertsRow, error) {
	rows, err := q.query(ctx, q.listActiveAlertsStmt, listActiveAlerts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveAlertsRow{}
	for rows.Next() {
		var i ListActiveAlertsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserUuid,
			&i.Email,
			&i.Phone,
			&i.ResortUuid,
			&i.ResortName,
			&i.MinSnowAmount,
			&i.NotificationDays,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserAlert = `-- name: UpdateUserAlert :one
UPDATE user_alerts
SET min_snow_amount   = $3,
    notification_days = $4,
    active            = $5
WHERE user_uuid = $1
  AND resort_uuid = $2 RETURNING id, user_uuid, resort_uuid, min_snow_amount, notification_days, active, created_at
`

type UpdateUserAlertParams struct {
	UserUuid         uuid.NullUUID `json:"user_uuid"`
	ResortUuid       uuid.NullUUID `json:"resort_uuid"`
	MinSnowAmount    float64       `json:"min_snow_amount"`
	NotificationDays int32         `json:"notification_days"`
	Active           sql.NullBool  `json:"active"`
}

func (q *Queries) UpdateUserAlert(ctx context.Context, arg UpdateUserAlertParams) (UserAlert, error) {
	row := q.queryRow(ctx, q.updateUserAlertStmt, updateUserAlert,
		arg.UserUuid,
		arg.ResortUuid,
		arg.MinSnowAmount,
		arg.NotificationDays,
		arg.Active,
	)
	var i UserAlert
	err := row.Scan(
		&i.ID,
		&i.UserUuid,
		&i.ResortUuid,
		&i.MinSnowAmount,
		&i.NotificationDays,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}
